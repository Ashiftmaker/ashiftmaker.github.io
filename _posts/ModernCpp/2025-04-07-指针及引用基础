---
title: "指针及引用基础"
date: 2025-04-07 20:30:00 +0800
categories: [ModernCpp]
tags: [原始指针，引用]
math: true              # 启用数学公式
mermaid: true           # 启用流程图
toc: true               # 显示目录
image:  # 文章封面图
---
##指针*
本质：指针就是一个整数，是一个数字，它存储一个内存地址。
比喻：内存就像一条街道，街道上有很多的房子，每一个房子都住着一个Byte大小的数据，每一个房子的门牌号就是地址，而指针就是存储门牌号的一个变量
指针类型：我们给指针一个类型，只是说其所指向内存的地方很可能存储着那样一个类型的数据，比如说int* ptr,是我们告诉编译器ptr这个地址存储的变量要给四个字节的大小。
###操作
1.&引用:获取到某变量所在的内存的地址
2.*解引用:访问某内存，对其读写
指定一块确定大小的内存
```cpp
char* ptr = new char[8]//在堆上获取
3.双重指针:一个指向指针的指针，这个指针里面存储其它指针的地址
int a = 8;    //a的内存地址:0XFFFF
int* ptr = &a;//ptr=0xFFFFFFFF,*ptr=8,ptr的内存地址:0XAAAAAAAA
int** p = &ptr//p里面存储ptr的地址，p=0XAAAAAAAA，*p=ptr=0XFFFFFFFF,**p=*ptr=8
##引用&
引用是对于某个已存在的变量的引用。"引用变量"是对于某个已存在的变量的引用,它本身并不是一个新的变量，并不真正占用内存，因为它只是其它变量的引用而不是一个真正的变量
int a = 5;
int& ref = a;//ref"变量"并不是真正的变量，它是a的一个别名，ref只存在我们的源码里面，编译的时候不会创建两个变量，只会创建a
###引用传递
void main()
{
  int a = 5;
  Increment(a);
  std::cout<<a;
}
第一种传值调用:执行完这个函数之后a还是5,输出是5，a没有改变，只是把a的值拿去用了
void Increment(int value)
{
  //int value = 5;相当于在这里新建一个变量来接受a的值（5）
  value++;//value=6;
}
第二种引用传递:把变量a传递到函数进行处理;处理完后a的值变成6
void Increment(int& value)
{
  //value是a的一个别名，并没有创建value这个变量，对value做的所有操作其实就是在对a操作
  value++;//value=6也就是a=6;
}
引用相当于实现了指针操作，但是让代码更加的易读,没有任何事情是引用能做但是指针做不了的(引用是指针的扩展，在计算机处理指针和引用两种关键字的角度来看，二者基本一致)
以上引用实现等效于:
Increment(&a);
void Increment(int* value)
{
  (*value)++;//a=6;
}
注意：一旦声明一个引用就不能在改变它所引用的对象
      声明即须赋值
